import {
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onMount,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_attributes,
  set_custom_element_data_map,
  set_data_dev,
  set_input_value,
  space,
  src_url_equal,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-K6MJRMI7.js";
import {
  __export
} from "./chunk-JC4IRQUL.js";

// node_modules/svelte-formly/utils/stores.js
var formsStore = writable([]);
function createForms() {
  const { subscribe, set, update } = writable([]);
  return {
    subscribe,
    // add new form
    save: (newForm) => update((forms) => {
      const form = forms.find((form2) => form2.form_name === newForm.form_name);
      if (!form) {
        forms = [...forms, newForm];
      } else {
        forms = forms.map((form2) => form2.form_name === newForm.form_name ? newForm : form2);
      }
      return forms;
    }),
    // remove forms.
    reset: () => set([]),
    // remove values form by name
    resetValues: (form_name) => update((forms) => {
      forms.map((form) => {
        if (form.form_name === form_name) {
          form.fields.map((field) => {
            field.value = null;
            form.values[field.name] = null;
          });
        }
        return form;
      });
      return forms;
    }),
    // update value field
    updateFieldValue: (form_name, field_name, field_value) => update((forms) => {
      const _forms = forms.map((form) => {
        if (form.form_name === form_name) {
          form.fields.map((field) => {
            if (field.name === field_name) {
              field.value = field_value;
              form.values[field_name] = field_value;
              form.values["touched"] = field_name;
            }
            return field;
          });
        }
        return form;
      });
      return _forms;
    })
  };
}
var storeForms = createForms();

// node_modules/svelte-formly/utils/validation/rules/index.js
var rules_exports = {};
__export(rules_exports, {
  between: () => between,
  bytesToSize: () => bytesToSize,
  email: () => email,
  equal: () => equal,
  extensions: () => extensions,
  getFileExtension: () => getFileExtension,
  max: () => max,
  maxSize: () => maxSize,
  min: () => min,
  required: () => required,
  url: () => url
});

// node_modules/svelte-formly/utils/validation/rules/min.js
function min(val, args) {
  const minValue = parseFloat(args[0]);
  val = val ? val : "";
  const value = isNaN(val) ? val.length : parseFloat(val);
  return value >= minValue;
}

// node_modules/svelte-formly/utils/validation/rules/max.js
function max(val, args) {
  const maxValue = parseFloat(args[0]);
  val = val ? val : "";
  const value = isNaN(val) ? val.length : parseFloat(val);
  return isNaN(value) ? true : value <= maxValue;
}

// node_modules/svelte-formly/utils/validation/rules/between.js
function between(val, args) {
  return min(val, [args[0]]) && max(val, [args[1]]);
}

// node_modules/svelte-formly/utils/validation/rules/email.js
function email(val, args) {
  const regex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return val && regex.test(val);
}

// node_modules/svelte-formly/utils/validation/rules/required.js
function required(val, args) {
  if (val === void 0 || val === null || val === "undefined" || val === "null" || val === null || Number.isNaN(val)) {
    return false;
  }
  if (typeof val === "string") {
    const tmp = val.replace(/\s/g, "");
    return tmp.length > 0;
  }
  if (typeof val === "object") {
    return val.length > 0;
  }
  return true;
}

// node_modules/svelte-formly/utils/validation/rules/url.js
function url(val, args) {
  const regex = /(https?|ftp|git|svn):\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/i;
  return regex.test(val);
}

// node_modules/svelte-formly/utils/validation/rules/equal.js
function equal(val, args) {
  return val === args[0];
}

// node_modules/svelte-formly/utils/validation/rules/file.js
function bytesToSize(bytes) {
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  if (bytes === 0)
    return "n/a";
  const bytes_flor = Math.floor(Math.log(bytes) / Math.log(1024));
  const i = parseInt(bytes_flor.toString(), 10);
  if (i === 0)
    return `${bytes} ${sizes[i]})`;
  return `${(bytes / 1024 ** i).toFixed(1)} ${sizes[i]}`;
}
function getFileExtension(file12) {
  const filenameParts = file12.name.split(".");
  return filenameParts[filenameParts.length - 1].toLowerCase();
}
function extensions(file12, allowedFileTypes) {
  if (!allowedFileTypes.includes(getFileExtension(file12))) {
    return false;
  }
  return true;
}
function maxSize(file12, maxFileSize) {
  const maxSize2 = parseFloat(maxFileSize) * 1024 * 1024;
  if (file12.size > maxSize2) {
    return false;
  }
  return true;
}

// node_modules/svelte-formly/utils/validation/index.js
var _coreRules = rules_exports;
async function validate(_field) {
  let { value, rules } = _field;
  let valid = true;
  let rule;
  let errors = [];
  let validation;
  if (rules) {
    await Promise.all(rules.map(async (validator) => {
      if (validator === "file") {
        if (value) {
          Object.keys(value).map((i) => {
            if (_field.file) {
              Object.entries(_field.file).map(([key, val]) => {
                valid = _coreRules[key].call(null, value[i], val);
                if (!valid) {
                  errors = [...errors, key];
                }
              });
            }
          });
        }
      } else {
        if (typeof validator === "function") {
          valid = await validator.call;
          rule = validator.name;
        } else if (typeof validator === "object") {
          valid = await validator.fnc();
          rule = validator.name;
        } else {
          const args = validator.split(/:/g);
          rule = args.shift();
          valid = _coreRules[rule].call(null, value, args);
        }
        if (!valid) {
          errors = [...errors, rule];
        }
      }
    }));
    validation = { errors, dirty: errors.length > 0 };
  } else {
    validation = { errors, dirty: false };
  }
  _field.validation = validation;
  return _field;
}

// node_modules/svelte-formly/utils/form.js
async function getFormByName(form_name) {
  const forms = await get_store_value(storeForms);
  const form = forms.find((form2) => form2.form_name === form_name);
  return form ?? null;
}
async function preprocessField(field, fields, values) {
  const fnc = field.preprocess;
  field = await (fnc == null ? void 0 : fnc.call(null, field, fields, values));
  return field;
}
async function getValues(form_name) {
  const forms = await get_store_value(storeForms);
  const form = forms.find((form2) => form2.form_name === form_name);
  return form ? form == null ? void 0 : form.values : {};
}
async function preprocess_and_validate_field(form, field, values) {
  if (field.preprocess) {
    field = await preprocessField(field, form.fields, values);
    values[`${field.name}`] = field.value ?? null;
  }
  if (field.rules) {
    field = await validate(field);
  }
  return field;
}

// node_modules/svelte-formly/utils/helper.js
function inArray(arr, element2) {
  if (arr.indexOf(element2) != -1) {
    return true;
  }
  return false;
}
function isRequired(field) {
  if (field.rules) {
    if (field.rules.length > 0) {
      return true;
    }
  }
  return false;
}
function isFieldDuplicated(fields) {
  let seen = {};
  return fields.some(function(currentObject) {
    if (seen.hasOwnProperty(currentObject.name) || seen.hasOwnProperty(currentObject.attributes.id)) {
      return true;
    }
    return seen[currentObject.name] = false, seen[currentObject.attributes.id] = false;
  });
}
function clickOutside(node) {
  const handleClick = (event) => {
    if (node && !node.contains(event.target) && !event.defaultPrevented) {
      node.dispatchEvent(new CustomEvent("click_outside", node));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}

// node_modules/svelte-formly/components/Error.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Error", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Error> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Error2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Error",
      options,
      id: create_fragment.name
    });
  }
};
var Error_default = Error2;

// node_modules/svelte-formly/components/Tag.svelte
var file = "node_modules\\svelte-formly\\components\\Tag.svelte";
function create_dynamic_element(ctx) {
  var _a;
  let svelte_element;
  let svelte_element_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*prefix*/
      (_a = ctx[0].classes) == null ? void 0 : _a.join(" ")
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*prefix*/
        ctx[0].tag ?? "div"
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*prefix*/
        ((ctx[0].tag ?? "div") || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (/-/.test(
        /*prefix*/
        ctx[0].tag ?? "div"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file, 3, 0, 38);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*prefix*/
        1 && svelte_element_class_value !== (svelte_element_class_value = /*prefix*/
        (_a2 = ctx2[0].classes) == null ? void 0 : _a2.join(" "))) && { class: svelte_element_class_value }
      ]);
      if (/-/.test(
        /*prefix*/
        ctx2[0].tag ?? "div"
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(4:0) <svelte:element this={prefix.tag ?? 'div'} class={prefix.classes?.join(' ')}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let previous_tag = (
    /*prefix*/
    ctx[0].tag ?? "div"
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*prefix*/
    ctx[0].tag ?? "div"
  );
  validate_void_dynamic_element(
    /*prefix*/
    ctx[0].tag ?? "div"
  );
  let svelte_element = (
    /*prefix*/
    (ctx[0].tag ?? "div") && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*prefix*/
        ctx2[0].tag ?? "div"
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*prefix*/
          ctx2[0].tag ?? "div"
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*prefix*/
            ctx2[0].tag ?? "div"
          );
          validate_void_dynamic_element(
            /*prefix*/
            ctx2[0].tag ?? "div"
          );
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*prefix*/
      ctx2[0].tag ?? "div";
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tag", slots, ["default"]);
  let { prefix } = $$props;
  $$self.$$.on_mount.push(function() {
    if (prefix === void 0 && !("prefix" in $$props || $$self.$$.bound[$$self.$$.props["prefix"]])) {
      console.warn("<Tag> was created without expected prop 'prefix'");
    }
  });
  const writable_props = ["prefix"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tag> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("prefix" in $$props2)
      $$invalidate(0, prefix = $$props2.prefix);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ prefix });
  $$self.$inject_state = ($$props2) => {
    if ("prefix" in $$props2)
      $$invalidate(0, prefix = $$props2.prefix);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [prefix, $$scope, slots];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { prefix: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment2.name
    });
  }
  get prefix() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;

// node_modules/svelte-formly/components/Message.svelte
var file2 = "node_modules\\svelte-formly\\components\\Message.svelte";
function create_if_block(ctx) {
  let div;
  let t_value = (
    /*displayError*/
    ctx[1](
      /*error*/
      ctx[0]
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "invalid-feedback error");
      add_location(div, file2, 30, 1, 1122);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*error*/
      1 && t_value !== (t_value = /*displayError*/
      ctx2[1](
        /*error*/
        ctx2[0]
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(30:0) {#if error}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let if_block = (
    /*error*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*error*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Message", slots, []);
  let { error } = $$props;
  let { messages = {} } = $$props;
  const rules = [
    {
      rule: "required",
      message: "This field is required"
    },
    {
      rule: "min",
      message: "This field must be more characters long"
    },
    {
      rule: "max",
      message: "This field must be less characters long"
    },
    {
      rule: "between",
      message: "This field must be between values defined"
    },
    {
      rule: "equal",
      message: "This field must be equal to value defined"
    },
    {
      rule: "email",
      message: "This email format is not valid"
    },
    {
      rule: "extensions",
      message: "Must to allowed file types"
    },
    {
      rule: "maxSize",
      message: "This file has size more than max size"
    },
    { rule: "custom_rule", message: "Error" }
  ];
  const displayError = (rule) => {
    let message = "";
    if (messages[rule]) {
      message += messages[rule] ?? getMessageByRule(rule);
    } else {
      message += getMessageByRule(rule);
    }
    return message;
  };
  const getMessageByRule = (rule) => {
    const data = rules.find((r) => r.rule === rule);
    return data ? data.message : rules.find((r) => r.rule === "custom_rule").message;
  };
  $$self.$$.on_mount.push(function() {
    if (error === void 0 && !("error" in $$props || $$self.$$.bound[$$self.$$.props["error"]])) {
      console.warn("<Message> was created without expected prop 'error'");
    }
  });
  const writable_props = ["error", "messages"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Message> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("error" in $$props2)
      $$invalidate(0, error = $$props2.error);
    if ("messages" in $$props2)
      $$invalidate(2, messages = $$props2.messages);
  };
  $$self.$capture_state = () => ({
    error,
    messages,
    rules,
    displayError,
    getMessageByRule
  });
  $$self.$inject_state = ($$props2) => {
    if ("error" in $$props2)
      $$invalidate(0, error = $$props2.error);
    if ("messages" in $$props2)
      $$invalidate(2, messages = $$props2.messages);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [error, displayError, messages];
}
var Message = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { error: 0, messages: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Message",
      options,
      id: create_fragment3.name
    });
  }
  get error() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messages() {
    throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messages(value) {
    throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Message_default = Message;

// node_modules/svelte-formly/components/Dirty.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*field*/
    ctx[0].validation.errors
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field*/
      1) {
        each_value = /*field*/
        ctx2[0].validation.errors;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(5:0) {#if field.validation && field.validation.errors.length}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let message;
  let current;
  message = new Message_default({
    props: {
      error: (
        /*error*/
        ctx[1]
      ),
      messages: (
        /*field*/
        ctx[0].messages ? (
          /*field*/
          ctx[0].messages
        ) : []
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(message.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(message.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(message, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const message_changes = {};
      if (dirty & /*field*/
      1)
        message_changes.error = /*error*/
        ctx2[1];
      if (dirty & /*field*/
      1)
        message_changes.messages = /*field*/
        ctx2[0].messages ? (
          /*field*/
          ctx2[0].messages
        ) : [];
      message.$set(message_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(message.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(message, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(6:1) {#each field.validation.errors as error}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*field*/
    ctx[0].validation && /*field*/
    ctx[0].validation.errors.length && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*field*/
        ctx2[0].validation && /*field*/
        ctx2[0].validation.errors.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*field*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dirty", slots, []);
  let { field } = $$props;
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Dirty> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dirty> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({ Message: Message_default, field });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field];
}
var Dirty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dirty",
      options,
      id: create_fragment4.name
    });
  }
  get field() {
    throw new Error("<Dirty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Dirty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dirty_default = Dirty;

// node_modules/svelte-formly/components/fields/Input.svelte
var file3 = "node_modules\\svelte-formly\\components\\fields\\Input.svelte";
function create_fragment5(ctx) {
  let input;
  let input_value_value;
  let input_type_value;
  let input_id_value;
  let input_class_value;
  let input_placeholder_value;
  let input_required_value;
  let input_disabled_value;
  let input_readonly_value;
  let input_min_value;
  let input_max_value;
  let input_step_value;
  let input_autocomplete_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        class: true,
        placeholder: true,
        min: true,
        max: true,
        step: true,
        autocomplete: true
      });
      this.h();
    },
    h: function hydrate() {
      var _a;
      input.value = input_value_value = /*field*/
      ctx[0].value ?? null;
      attr_dev(input, "type", input_type_value = /*field*/
      ctx[0].attributes.type);
      attr_dev(input, "id", input_id_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(input, "class", input_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      attr_dev(input, "placeholder", input_placeholder_value = /*field*/
      ctx[0].attributes.placeholder);
      input.required = input_required_value = isRequired(
        /*field*/
        ctx[0]
      );
      input.disabled = input_disabled_value = /*field*/
      ctx[0].attributes.disabled;
      input.readOnly = input_readonly_value = /*field*/
      ctx[0].attributes.readonly;
      attr_dev(input, "min", input_min_value = /*field*/
      ctx[0].attributes.min);
      attr_dev(input, "max", input_max_value = /*field*/
      ctx[0].attributes.max);
      attr_dev(input, "step", input_step_value = /*field*/
      ctx[0].attributes.step);
      attr_dev(input, "autocomplete", input_autocomplete_value = /*field*/
      ctx[0].attributes.autocomplete);
      add_location(input, file3, 16, 0, 471);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*onInput*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      if (dirty & /*field*/
      1 && input_value_value !== (input_value_value = /*field*/
      ctx2[0].value ?? null) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (dirty & /*field*/
      1 && input_type_value !== (input_type_value = /*field*/
      ctx2[0].attributes.type)) {
        attr_dev(input, "type", input_type_value);
      }
      if (dirty & /*field*/
      1 && input_id_value !== (input_id_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*field*/
      1 && input_class_value !== (input_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*field*/
      1 && input_placeholder_value !== (input_placeholder_value = /*field*/
      ctx2[0].attributes.placeholder)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*field*/
      1 && input_required_value !== (input_required_value = isRequired(
        /*field*/
        ctx2[0]
      ))) {
        prop_dev(input, "required", input_required_value);
      }
      if (dirty & /*field*/
      1 && input_disabled_value !== (input_disabled_value = /*field*/
      ctx2[0].attributes.disabled)) {
        prop_dev(input, "disabled", input_disabled_value);
      }
      if (dirty & /*field*/
      1 && input_readonly_value !== (input_readonly_value = /*field*/
      ctx2[0].attributes.readonly)) {
        prop_dev(input, "readOnly", input_readonly_value);
      }
      if (dirty & /*field*/
      1 && input_min_value !== (input_min_value = /*field*/
      ctx2[0].attributes.min)) {
        attr_dev(input, "min", input_min_value);
      }
      if (dirty & /*field*/
      1 && input_max_value !== (input_max_value = /*field*/
      ctx2[0].attributes.max)) {
        attr_dev(input, "max", input_max_value);
      }
      if (dirty & /*field*/
      1 && input_step_value !== (input_step_value = /*field*/
      ctx2[0].attributes.step)) {
        attr_dev(input, "step", input_step_value);
      }
      if (dirty & /*field*/
      1 && input_autocomplete_value !== (input_autocomplete_value = /*field*/
      ctx2[0].attributes.autocomplete)) {
        attr_dev(input, "autocomplete", input_autocomplete_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  const onInput = async (event) => {
    const value = field.attributes.type === "number" || field.attributes.type === "range" ? parseInt(event.currentTarget.value) : event.currentTarget.value;
    dispatch("changeValue", { name: field.name, value });
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Input> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Input> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    isRequired,
    field,
    dispatch,
    onInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, onInput];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment5.name
    });
  }
  get field() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/svelte-formly/components/fields/Select.svelte
var file4 = "node_modules\\svelte-formly\\components\\fields\\Select.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_if_block3(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[0].extra.options && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*field*/
        ctx2[0].extra.options
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(52:1) {#if field.extra}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let each_value = (
    /*field*/
    ctx[0].extra.options
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field, checkSelected*/
      5) {
        each_value = /*field*/
        ctx2[0].extra.options;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(53:2) {#if field.extra.options}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let option;
  let t0_value = (
    /*option*/
    ctx[5].title + ""
  );
  let t0;
  let t1;
  let option_value_value;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*option*/
      ctx[5].value;
      option.value = option.__value;
      option.selected = option_selected_value = /*checkSelected*/
      ctx[2](
        /*option*/
        ctx[5].value,
        /*field*/
        ctx[0].value
      );
      add_location(option, file4, 54, 4, 1638);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field*/
      1 && t0_value !== (t0_value = /*option*/
      ctx2[5].title + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*field*/
      1 && option_value_value !== (option_value_value = /*option*/
      ctx2[5].value)) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (dirty & /*field*/
      1 && option_selected_value !== (option_selected_value = /*checkSelected*/
      ctx2[2](
        /*option*/
        ctx2[5].value,
        /*field*/
        ctx2[0].value
      ))) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(54:3) {#each field.extra.options as option}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let select;
  let select_name_value;
  let select_id_value;
  let select_class_value;
  let select_required_value;
  let select_disabled_value;
  let select_multiple_value_1;
  let mounted;
  let dispose;
  let if_block = (
    /*field*/
    ctx[0].extra && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      select = element("select");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { name: true, id: true, class: true });
      var select_nodes = children(select);
      if (if_block)
        if_block.l(select_nodes);
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(select, "name", select_name_value = /*field*/
      ctx[0].name);
      attr_dev(select, "id", select_id_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(select, "class", select_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      select.required = select_required_value = isRequired(
        /*field*/
        ctx[0]
      );
      select.disabled = select_disabled_value = /*field*/
      ctx[0].attributes.disabled;
      select.multiple = select_multiple_value_1 = /*field*/
      ctx[0].extra && /*field*/
      ctx[0].extra.multiple ? (
        /*field*/
        ctx[0].extra.multiple
      ) : false;
      add_location(select, file4, 42, 0, 1272);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      if (if_block)
        if_block.m(select, null);
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*onChangeValue*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      if (
        /*field*/
        ctx2[0].extra
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(select, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*field*/
      1 && select_name_value !== (select_name_value = /*field*/
      ctx2[0].name)) {
        attr_dev(select, "name", select_name_value);
      }
      if (dirty & /*field*/
      1 && select_id_value !== (select_id_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(select, "id", select_id_value);
      }
      if (dirty & /*field*/
      1 && select_class_value !== (select_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(select, "class", select_class_value);
      }
      if (dirty & /*field*/
      1 && select_required_value !== (select_required_value = isRequired(
        /*field*/
        ctx2[0]
      ))) {
        prop_dev(select, "required", select_required_value);
      }
      if (dirty & /*field*/
      1 && select_disabled_value !== (select_disabled_value = /*field*/
      ctx2[0].attributes.disabled)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (dirty & /*field*/
      1 && select_multiple_value_1 !== (select_multiple_value_1 = /*field*/
      ctx2[0].extra && /*field*/
      ctx2[0].extra.multiple ? (
        /*field*/
        ctx2[0].extra.multiple
      ) : false)) {
        prop_dev(select, "multiple", select_multiple_value_1);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  const is_multiple = field.extra.multiple ?? false;
  const onChangeValue = async (event) => {
    let value;
    if (is_multiple) {
      let values = [];
      const selectedOptions = event.currentTarget.selectedOptions;
      for (let i = 0; i < selectedOptions.length; i++) {
        const value_item = selectedOptions[i].value;
        values = [...values, value_item];
      }
      value = values;
    } else {
      value = event.currentTarget.value;
    }
    dispatch("changeValue", { name: field.name, value });
  };
  const checkSelected = (option_value, field_value) => {
    if (is_multiple) {
      if (field_value && field_value.length) {
        const res = field_value.indexOf(option_value) != -1;
        return res;
      } else if (field.value && field.value.length) {
        const res = field.value.indexOf(option_value) != -1;
        return res;
      }
      return false;
    }
    return option_value === field_value;
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Select> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    isRequired,
    field,
    dispatch,
    is_multiple,
    onChangeValue,
    checkSelected
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, onChangeValue, checkSelected];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment6.name
    });
  }
  get field() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/svelte-formly/components/fields/File.svelte
var { Object: Object_1 } = globals;
var file5 = "node_modules\\svelte-formly\\components\\fields\\File.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  child_ctx[12] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i][0];
  child_ctx[14] = list[i][1];
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  let ul;
  let each_value_1 = Object.entries(
    /*field*/
    ctx[0].file
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file5, 51, 2, 1163);
      attr_dev(div, "class", "file-rules");
      add_location(div, file5, 50, 1, 1136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Object, field*/
      1) {
        each_value_1 = Object.entries(
          /*field*/
          ctx2[0].file
        );
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(50:0) {#if field.file}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let li;
  let strong;
  let t0_value = (
    /*rule*/
    ctx[13] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*ruleValue*/
    ctx[14] + ""
  );
  let t2;
  const block = {
    c: function create() {
      li = element("li");
      strong = element("strong");
      t0 = text(t0_value);
      t1 = text(": ");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      strong = claim_element(li_nodes, "STRONG", {});
      var strong_nodes = children(strong);
      t0 = claim_text(strong_nodes, t0_value);
      strong_nodes.forEach(detach_dev);
      t1 = claim_text(li_nodes, ": ");
      t2 = claim_text(li_nodes, t2_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file5, 53, 8, 1235);
      add_location(li, file5, 53, 4, 1231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, strong);
      append_hydration_dev(strong, t0);
      append_hydration_dev(li, t1);
      append_hydration_dev(li, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field*/
      1 && t0_value !== (t0_value = /*rule*/
      ctx2[13] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*field*/
      1 && t2_value !== (t2_value = /*ruleValue*/
      ctx2[14] + ""))
        set_data_dev(t2, t2_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(53:3) {#each Object.entries(field.file) as [rule, ruleValue]}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*files*/
    ctx[1] && create_if_block_12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*files*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(60:0) {#if showPreview}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let each_value = (
    /*files*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "list-files");
      add_location(div, file5, 61, 2, 1344);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*deleteFile, files, window*/
      34) {
        each_value = /*files*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(61:1) {#if files}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let div2;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let ul;
  let li0;
  let t1;
  let t2_value = (
    /*file*/
    ctx[10].name + ""
  );
  let t2;
  let t3;
  let li1;
  let t4;
  let t5_value = (
    /*file*/
    ctx[10].size + ""
  );
  let t5;
  let t6;
  let li2;
  let t7;
  let t8_value = (
    /*file*/
    ctx[10].type + ""
  );
  let t8;
  let t9;
  let li3;
  let button;
  let t10;
  let t11;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[8](
        /*file*/
        ctx[10]
      )
    );
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      ul = element("ul");
      li0 = element("li");
      t1 = text("Name: ");
      t2 = text(t2_value);
      t3 = space();
      li1 = element("li");
      t4 = text("Size: ");
      t5 = text(t5_value);
      t6 = space();
      li2 = element("li");
      t7 = text("Type: ");
      t8 = text(t8_value);
      t9 = space();
      li3 = element("li");
      button = element("button");
      t10 = text("Remove");
      t11 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      img = claim_element(div0_nodes, "IMG", { src: true, alt: true });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      ul = claim_element(div1_nodes, "UL", {});
      var ul_nodes = children(ul);
      li0 = claim_element(ul_nodes, "LI", {});
      var li0_nodes = children(li0);
      t1 = claim_text(li0_nodes, "Name: ");
      t2 = claim_text(li0_nodes, t2_value);
      li0_nodes.forEach(detach_dev);
      t3 = claim_space(ul_nodes);
      li1 = claim_element(ul_nodes, "LI", {});
      var li1_nodes = children(li1);
      t4 = claim_text(li1_nodes, "Size: ");
      t5 = claim_text(li1_nodes, t5_value);
      li1_nodes.forEach(detach_dev);
      t6 = claim_space(ul_nodes);
      li2 = claim_element(ul_nodes, "LI", {});
      var li2_nodes = children(li2);
      t7 = claim_text(li2_nodes, "Type: ");
      t8 = claim_text(li2_nodes, t8_value);
      li2_nodes.forEach(detach_dev);
      t9 = claim_space(ul_nodes);
      li3 = claim_element(ul_nodes, "LI", {});
      var li3_nodes = children(li3);
      button = claim_element(li3_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t10 = claim_text(button_nodes, "Remove");
      button_nodes.forEach(detach_dev);
      li3_nodes.forEach(detach_dev);
      ul_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t11 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = window.URL.createObjectURL(
        /*file*/
        ctx[10]
      )))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", img_alt_value = /*file*/
      ctx[10].name);
      add_location(img, file5, 65, 6, 1449);
      attr_dev(div0, "class", "img");
      add_location(div0, file5, 64, 5, 1425);
      add_location(li0, file5, 69, 7, 1567);
      add_location(li1, file5, 70, 7, 1601);
      add_location(li2, file5, 71, 7, 1635);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "btn");
      add_location(button, file5, 73, 8, 1682);
      add_location(li3, file5, 72, 7, 1669);
      add_location(ul, file5, 68, 6, 1555);
      attr_dev(div1, "class", "infos");
      add_location(div1, file5, 67, 5, 1529);
      attr_dev(div2, "class", "file");
      add_location(div2, file5, 63, 4, 1401);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, img);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, ul);
      append_hydration_dev(ul, li0);
      append_hydration_dev(li0, t1);
      append_hydration_dev(li0, t2);
      append_hydration_dev(ul, t3);
      append_hydration_dev(ul, li1);
      append_hydration_dev(li1, t4);
      append_hydration_dev(li1, t5);
      append_hydration_dev(ul, t6);
      append_hydration_dev(ul, li2);
      append_hydration_dev(li2, t7);
      append_hydration_dev(li2, t8);
      append_hydration_dev(ul, t9);
      append_hydration_dev(ul, li3);
      append_hydration_dev(li3, button);
      append_hydration_dev(button, t10);
      append_hydration_dev(div2, t11);
      if (!mounted) {
        dispose = listen_dev(button, "click", prevent_default(click_handler), false, true, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*files*/
      2 && !src_url_equal(img.src, img_src_value = window.URL.createObjectURL(
        /*file*/
        ctx[10]
      ))) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*files*/
      2 && img_alt_value !== (img_alt_value = /*file*/
      ctx[10].name)) {
        attr_dev(img, "alt", img_alt_value);
      }
      if (dirty & /*files*/
      2 && t2_value !== (t2_value = /*file*/
      ctx[10].name + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*files*/
      2 && t5_value !== (t5_value = /*file*/
      ctx[10].size + ""))
        set_data_dev(t5, t5_value);
      if (dirty & /*files*/
      2 && t8_value !== (t8_value = /*file*/
      ctx[10].type + ""))
        set_data_dev(t8, t8_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(63:3) {#each files as file, i}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let input;
  let input_type_value;
  let input_name_value;
  let input_id_value;
  let input_class_value;
  let t0;
  let t1;
  let if_block1_anchor;
  let mounted;
  let dispose;
  let if_block0 = (
    /*field*/
    ctx[0].file && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*showPreview*/
    ctx[3] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        name: true,
        id: true,
        class: true
      });
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(input, "type", input_type_value = /*field*/
      ctx[0].type);
      attr_dev(input, "name", input_name_value = /*field*/
      ctx[0].name);
      attr_dev(input, "id", input_id_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(input, "class", input_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      input.multiple = /*multiple*/
      ctx[2];
      add_location(input, file5, 39, 0, 943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[7](input);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*onInput*/
          ctx[6],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      if (dirty & /*field*/
      1 && input_type_value !== (input_type_value = /*field*/
      ctx2[0].type)) {
        attr_dev(input, "type", input_type_value);
      }
      if (dirty & /*field*/
      1 && input_name_value !== (input_name_value = /*field*/
      ctx2[0].name)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*field*/
      1 && input_id_value !== (input_id_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*field*/
      1 && input_class_value !== (input_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*multiple*/
      4) {
        prop_dev(
          input,
          "multiple",
          /*multiple*/
          ctx2[2]
        );
      }
      if (
        /*field*/
        ctx2[0].file
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showPreview*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[7](null);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("File", slots, []);
  let { field } = $$props;
  let files = [];
  let multiple = false;
  let showPreview = false;
  let inputFile;
  const dispatch = createEventDispatcher();
  onMount(() => {
    if (field.extra) {
      $$invalidate(2, multiple = field.extra.multiple ? field.extra.multiple : null);
      $$invalidate(3, showPreview = field.extra.showPreview ? field.extra.showPreview : null);
    }
  });
  function deleteFile(file12) {
    let newValue;
    $$invalidate(1, files = files.filter((i) => i.name != file12.name));
    if (files.length === 0) {
      $$invalidate(4, inputFile.value = null, inputFile);
      newValue = null;
    } else {
      newValue = files;
    }
    dispatch("changeValue", { name: field.name, value: newValue });
  }
  const onInput = async (event) => {
    $$invalidate(1, files = Array.from(event.currentTarget.files));
    dispatch("changeValue", { name: field.name, value: files });
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<File> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<File> was created with unknown prop '${key}'`);
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputFile = $$value;
      $$invalidate(4, inputFile);
    });
  }
  const click_handler = (file12) => {
    deleteFile(file12);
  };
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    field,
    files,
    multiple,
    showPreview,
    inputFile,
    dispatch,
    deleteFile,
    onInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("files" in $$props2)
      $$invalidate(1, files = $$props2.files);
    if ("multiple" in $$props2)
      $$invalidate(2, multiple = $$props2.multiple);
    if ("showPreview" in $$props2)
      $$invalidate(3, showPreview = $$props2.showPreview);
    if ("inputFile" in $$props2)
      $$invalidate(4, inputFile = $$props2.inputFile);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    field,
    files,
    multiple,
    showPreview,
    inputFile,
    deleteFile,
    onInput,
    input_binding,
    click_handler
  ];
}
var File = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "File",
      options,
      id: create_fragment7.name
    });
  }
  get field() {
    throw new Error("<File>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<File>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var File_default = File;

// node_modules/svelte-formly/components/fields/Textarea.svelte
var file6 = "node_modules\\svelte-formly\\components\\fields\\Textarea.svelte";
function create_fragment8(ctx) {
  let textarea;
  let textarea_value_value;
  let textarea_id_value;
  let textarea_class_value;
  let textarea_placeholder_value;
  let textarea_required_value;
  let textarea_disabled_value;
  let textarea_readonly_value;
  let textarea_rows_value;
  let textarea_cols_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", {
        id: true,
        class: true,
        placeholder: true,
        rows: true,
        cols: true
      });
      children(textarea).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      textarea.value = textarea_value_value = /*field*/
      ctx[0].value ?? null;
      attr_dev(textarea, "id", textarea_id_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(textarea, "class", textarea_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      attr_dev(textarea, "placeholder", textarea_placeholder_value = /*field*/
      ctx[0].attributes.placeholder);
      textarea.required = textarea_required_value = isRequired(
        /*field*/
        ctx[0]
      );
      textarea.disabled = textarea_disabled_value = /*field*/
      ctx[0].attributes.disabled;
      textarea.readOnly = textarea_readonly_value = /*field*/
      ctx[0].attributes.readonly;
      attr_dev(textarea, "rows", textarea_rows_value = /*field*/
      ctx[0].attributes.rows);
      attr_dev(textarea, "cols", textarea_cols_value = /*field*/
      ctx[0].attributes.cols);
      add_location(textarea, file6, 14, 0, 343);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, textarea, anchor);
      if (!mounted) {
        dispose = listen_dev(
          textarea,
          "input",
          /*onInput*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      if (dirty & /*field*/
      1 && textarea_value_value !== (textarea_value_value = /*field*/
      ctx2[0].value ?? null)) {
        prop_dev(textarea, "value", textarea_value_value);
      }
      if (dirty & /*field*/
      1 && textarea_id_value !== (textarea_id_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(textarea, "id", textarea_id_value);
      }
      if (dirty & /*field*/
      1 && textarea_class_value !== (textarea_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(textarea, "class", textarea_class_value);
      }
      if (dirty & /*field*/
      1 && textarea_placeholder_value !== (textarea_placeholder_value = /*field*/
      ctx2[0].attributes.placeholder)) {
        attr_dev(textarea, "placeholder", textarea_placeholder_value);
      }
      if (dirty & /*field*/
      1 && textarea_required_value !== (textarea_required_value = isRequired(
        /*field*/
        ctx2[0]
      ))) {
        prop_dev(textarea, "required", textarea_required_value);
      }
      if (dirty & /*field*/
      1 && textarea_disabled_value !== (textarea_disabled_value = /*field*/
      ctx2[0].attributes.disabled)) {
        prop_dev(textarea, "disabled", textarea_disabled_value);
      }
      if (dirty & /*field*/
      1 && textarea_readonly_value !== (textarea_readonly_value = /*field*/
      ctx2[0].attributes.readonly)) {
        prop_dev(textarea, "readOnly", textarea_readonly_value);
      }
      if (dirty & /*field*/
      1 && textarea_rows_value !== (textarea_rows_value = /*field*/
      ctx2[0].attributes.rows)) {
        attr_dev(textarea, "rows", textarea_rows_value);
      }
      if (dirty & /*field*/
      1 && textarea_cols_value !== (textarea_cols_value = /*field*/
      ctx2[0].attributes.cols)) {
        attr_dev(textarea, "cols", textarea_cols_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  const onInput = async (event) => {
    const value = event.currentTarget.value;
    dispatch("changeValue", { name: field.name, value });
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Textarea> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Textarea> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    isRequired,
    field,
    dispatch,
    onInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, onInput];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment8.name
    });
  }
  get field() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/svelte-formly/components/fields/Checkbox.svelte
var file7 = "node_modules\\svelte-formly\\components\\fields\\Checkbox.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let input;
  let input_type_value;
  let input_class_value;
  let input_value_value;
  let input_name_value;
  let input_checked_value;
  let input_required_value;
  let input_disabled_value;
  let t0;
  let span;
  let t1_value = (
    /*item*/
    ctx[4].title + ""
  );
  let t1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, class: true, name: true });
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(input, "type", input_type_value = /*field*/
      ctx[0].type);
      attr_dev(input, "class", input_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      input.value = input_value_value = /*item*/
      ctx[4].value;
      attr_dev(input, "name", input_name_value = /*item*/
      ctx[4].name);
      input.checked = input_checked_value = /*item*/
      ctx[4].checked ?? false;
      input.required = input_required_value = isRequired(
        /*field*/
        ctx[0]
      );
      input.disabled = input_disabled_value = /*field*/
      ctx[0].attributes.disabled;
      add_location(input, file7, 41, 1, 1174);
      add_location(span, file7, 51, 1, 1417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t1);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*onInput*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty & /*field*/
      1 && input_type_value !== (input_type_value = /*field*/
      ctx2[0].type)) {
        attr_dev(input, "type", input_type_value);
      }
      if (dirty & /*field*/
      1 && input_class_value !== (input_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*field*/
      1 && input_value_value !== (input_value_value = /*item*/
      ctx2[4].value) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (dirty & /*field*/
      1 && input_name_value !== (input_name_value = /*item*/
      ctx2[4].name)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*field*/
      1 && input_checked_value !== (input_checked_value = /*item*/
      ctx2[4].checked ?? false)) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (dirty & /*field*/
      1 && input_required_value !== (input_required_value = isRequired(
        /*field*/
        ctx2[0]
      ))) {
        prop_dev(input, "required", input_required_value);
      }
      if (dirty & /*field*/
      1 && input_disabled_value !== (input_disabled_value = /*field*/
      ctx2[0].attributes.disabled)) {
        prop_dev(input, "disabled", input_disabled_value);
      }
      if (dirty & /*field*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[4].title + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(41:0) {#each field.extra.items as item}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let each_1_anchor;
  let each_value = (
    /*field*/
    ctx[0].extra.items
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*field, isRequired, onInput*/
      3) {
        each_value = /*field*/
        ctx2[0].extra.items;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  let values = [];
  if (field.extra.items.length > 0) {
    field.extra.items.map((item) => {
      if (item.checked) {
        values = [...values, item.value];
        $$invalidate(0, field.value = field.value ? [...field.value, item.value] : values, field);
      }
    });
    dispatch("changeValue", { name: field.name, value: values });
  }
  const onInput = async (event) => {
    const value = event.currentTarget.value;
    if (field.extra.items.length > 0) {
      field.extra.items.map((item) => {
        if (item.name === event.currentTarget.name) {
          if (event.currentTarget.checked) {
            values = [...values, item.value];
          } else {
            values = values.filter((value2) => value2 !== item.value);
          }
        }
      });
      dispatch("changeValue", { name: field.name, value: values });
    }
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Checkbox> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Checkbox> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    isRequired,
    field,
    dispatch,
    values,
    onInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("values" in $$props2)
      values = $$props2.values;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, onInput];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment9.name
    });
  }
  get field() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/svelte-formly/components/fields/Radio.svelte
var file8 = "node_modules\\svelte-formly\\components\\fields\\Radio.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  child_ctx[5] = i;
  return child_ctx;
}
function create_each_block5(ctx) {
  let input;
  let input_type_value;
  let input_class_value;
  let input_id_value;
  let input_name_value;
  let input_value_value;
  let input_checked_value;
  let t0;
  let span;
  let t1_value = (
    /*item*/
    ctx[3].title + ""
  );
  let t1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        id: true,
        name: true
      });
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(input, "type", input_type_value = /*field*/
      ctx[0].type);
      attr_dev(input, "class", input_class_value = /*field*/
      (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" "));
      attr_dev(input, "id", input_id_value = /*item*/
      ctx[3].id);
      attr_dev(input, "name", input_name_value = /*field*/
      ctx[0].name);
      input.value = input_value_value = /*item*/
      ctx[3].value;
      input.checked = input_checked_value = /*item*/
      ctx[3].value === /*field*/
      ctx[0].value;
      add_location(input, file8, 14, 1, 339);
      add_location(span, file8, 23, 1, 533);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t1);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*onInput*/
          ctx[1],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty & /*field*/
      1 && input_type_value !== (input_type_value = /*field*/
      ctx2[0].type)) {
        attr_dev(input, "type", input_type_value);
      }
      if (dirty & /*field*/
      1 && input_class_value !== (input_class_value = /*field*/
      (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" "))) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*field*/
      1 && input_id_value !== (input_id_value = /*item*/
      ctx2[3].id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*field*/
      1 && input_name_value !== (input_name_value = /*field*/
      ctx2[0].name)) {
        attr_dev(input, "name", input_name_value);
      }
      if (dirty & /*field*/
      1 && input_value_value !== (input_value_value = /*item*/
      ctx2[3].value) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (dirty & /*field*/
      1 && input_checked_value !== (input_checked_value = /*item*/
      ctx2[3].value === /*field*/
      ctx2[0].value)) {
        prop_dev(input, "checked", input_checked_value);
      }
      if (dirty & /*field*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[3].title + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(14:0) {#each field.extra.items as item, i}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let each_1_anchor;
  let each_value = (
    /*field*/
    ctx[0].extra.items
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*field, onInput*/
      3) {
        each_value = /*field*/
        ctx2[0].extra.items;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radio", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  const onInput = async (event) => {
    const value = event.currentTarget.value;
    dispatch("changeValue", { name: field.name, value });
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Radio> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Radio> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    field,
    dispatch,
    onInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, onInput];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment10.name
    });
  }
  get field() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radio_default = Radio;

// node_modules/svelte-formly/components/fields/AutoComplete.svelte
var file9 = "node_modules\\svelte-formly\\components\\fields\\AutoComplete.svelte";
function add_css(target) {
  append_styles(target, "svelte-1m9l8b1", ".autocomplete-wrapper.svelte-1m9l8b1.svelte-1m9l8b1{position:relative;width:100%}.autocomplete-wrapper.svelte-1m9l8b1 .selected-items.svelte-1m9l8b1{margin-bottom:10px;width:100%;display:flex;flex-wrap:wrap;justify-content:flex-start;align-content:flex-start;gap:10px}.autocomplete-wrapper.svelte-1m9l8b1 .selected-items .item.svelte-1m9l8b1{font-size:0.75rem;padding:0.5rem;background-color:#ff3e00;color:white;border-radius:5px}.autocomplete-wrapper.svelte-1m9l8b1 .selected-items .item .deselect.svelte-1m9l8b1{border-radius:50%;width:15px;height:15px;padding:2px 7px 3px 7px;font-size:0.6rem;background-color:#333333;border:solid 1px rgba(255, 255, 255, 0.2);color:white}.autocomplete-wrapper.svelte-1m9l8b1 .selected-items .item .deselect.svelte-1m9l8b1:hover{box-shadow:0px 0px 4px 1px rgba(255, 255, 255, 0.8)}.autocomplete-wrapper.svelte-1m9l8b1 .selected-items .deselect.svelte-1m9l8b1{cursor:pointer}.autocomplete-wrapper.svelte-1m9l8b1 .list-items.svelte-1m9l8b1{box-shadow:0 2px 3px 0 rgba(249, 251, 253, 0.24);margin-bottom:20px}.autocomplete-wrapper.svelte-1m9l8b1 .list-items ul.svelte-1m9l8b1,.autocomplete-wrapper.svelte-1m9l8b1 .list-items li.svelte-1m9l8b1{list-style:none;padding:0;margin:0;color:black;background-color:rgb(201, 201, 201)}.autocomplete-wrapper.svelte-1m9l8b1 .list-items li.svelte-1m9l8b1{border-bottom:1px dashed #999999;padding:0.75rem;cursor:pointer}.autocomplete-wrapper.svelte-1m9l8b1 .list-items li.done.svelte-1m9l8b1{background-color:#1f2d38 !important;border-bottom-color:transparent;color:white;text-align:center}.autocomplete-wrapper.svelte-1m9l8b1 .list-items li.done.svelte-1m9l8b1:hover{border-bottom-color:transparent}.autocomplete-wrapper.svelte-1m9l8b1 .list-items li.svelte-1m9l8b1:hover{background-color:rgba(255, 64, 0, 0.6117647059);border-bottom:1px dashed #ff3e00;color:white}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0b0NvbXBsZXRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyR08scUJBQXFCLDhCQUFDLENBQUEsQUFDM0IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQUFDYixDQUFBLEFBQ0Esb0NBQXFCLENBQUMsZUFBZSxlQUFDLENBQUEsQUFDcEMsYUFBYSxDQUFFLElBQUksQ0FDbkIsS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxJQUFJLENBQ2YsZUFBZSxDQUFFLFVBQVUsQ0FDM0IsYUFBYSxDQUFFLFVBQVUsQ0FDekIsR0FBRyxDQUFFLElBQUksQUFDWCxDQUFBLEFBQ0Esb0NBQXFCLENBQUMsZUFBZSxDQUFDLEtBQUssZUFBQyxDQUFBLEFBQzFDLFNBQVMsQ0FBRSxPQUFPLENBQ2xCLE9BQU8sQ0FBRSxNQUFNLENBQ2YsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixLQUFLLENBQUUsS0FBSyxDQUNaLGFBQWEsQ0FBRSxHQUFHLEFBQ3BCLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLFNBQVMsZUFBQyxDQUFBLEFBQ3BELGFBQWEsQ0FBRSxHQUFHLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUN4QixTQUFTLENBQUUsTUFBTSxDQUNqQixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLE1BQU0sQ0FBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzFDLEtBQUssQ0FBRSxLQUFLLEFBQ2QsQ0FBQSxBQUNBLG9DQUFxQixDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsd0JBQVMsTUFBTSxBQUFDLENBQUEsQUFDMUQsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUN0RCxDQUFBLEFBQ0Esb0NBQXFCLENBQUMsZUFBZSxDQUFDLFNBQVMsZUFBQyxDQUFBLEFBQzlDLE1BQU0sQ0FBRSxPQUFPLEFBQ2pCLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxXQUFXLGVBQUMsQ0FBQSxBQUNoQyxVQUFVLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2pELGFBQWEsQ0FBRSxJQUFJLEFBQ3JCLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxXQUFXLENBQUMsaUJBQUUsQ0FDcEMsb0NBQXFCLENBQUMsV0FBVyxDQUFDLEVBQUUsZUFBQyxDQUFBLEFBQ25DLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsS0FBSyxDQUNaLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ3RDLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxXQUFXLENBQUMsRUFBRSxlQUFDLENBQUEsQUFDbkMsYUFBYSxDQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUNqQyxPQUFPLENBQUUsT0FBTyxDQUNoQixNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFBLEFBQ0Esb0NBQXFCLENBQUMsV0FBVyxDQUFDLEVBQUUsS0FBSyxlQUFDLENBQUEsQUFDeEMsZ0JBQWdCLENBQUUsT0FBTyxDQUFDLFVBQVUsQ0FDcEMsbUJBQW1CLENBQUUsV0FBVyxDQUNoQyxLQUFLLENBQUUsS0FBSyxDQUNaLFVBQVUsQ0FBRSxNQUFNLEFBQ3BCLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxXQUFXLENBQUMsRUFBRSxvQkFBSyxNQUFNLEFBQUMsQ0FBQSxBQUM5QyxtQkFBbUIsQ0FBRSxXQUFXLEFBQ2xDLENBQUEsQUFDQSxvQ0FBcUIsQ0FBQyxXQUFXLENBQUMsaUJBQUUsTUFBTSxBQUFDLENBQUEsQUFDekMsZ0JBQWdCLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FDaEQsYUFBYSxDQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUNqQyxLQUFLLENBQUUsS0FBSyxBQUNkLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQXV0b0NvbXBsZXRlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block_12(ctx) {
  let div;
  let span0;
  let t0_value = (
    /*item*/
    ctx[14].title + ""
  );
  let t0;
  let t1;
  let span1;
  let t2;
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("x");
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "x");
      span1_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file9, 70, 4, 1963);
      attr_dev(span1, "class", "deselect svelte-1m9l8b1");
      add_location(span1, file9, 71, 4, 1993);
      attr_dev(div, "class", "item svelte-1m9l8b1");
      add_location(div, file9, 69, 3, 1940);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(div, t3);
      if (!mounted) {
        dispose = listen_dev(
          span1,
          "click",
          function() {
            if (is_function(
              /*onDeselectItem*/
              ctx[7](
                /*item*/
                ctx[14]
              )
            ))
              ctx[7](
                /*item*/
                ctx[14]
              ).apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*selectedItems*/
      8 && t0_value !== (t0_value = /*item*/
      ctx[14].title + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(69:2) {#each selectedItems as item}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let div;
  let ul;
  let t0;
  let li;
  let t1;
  let clickOutside_action;
  let mounted;
  let dispose;
  let each_value = (
    /*itemsFiltered*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      li = element("li");
      t1 = text("Close");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      t0 = claim_space(ul_nodes);
      li = claim_element(ul_nodes, "LI", { class: true });
      var li_nodes = children(li);
      t1 = claim_text(li_nodes, "Close");
      li_nodes.forEach(detach_dev);
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "done svelte-1m9l8b1");
      add_location(li, file9, 93, 4, 2591);
      attr_dev(ul, "class", "svelte-1m9l8b1");
      add_location(ul, file9, 89, 3, 2479);
      attr_dev(div, "class", "list-items svelte-1m9l8b1");
      add_location(div, file9, 88, 2, 2400);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      append_hydration_dev(ul, t0);
      append_hydration_dev(ul, li);
      append_hydration_dev(li, t1);
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false
          ),
          action_destroyer(clickOutside_action = clickOutside.call(null, div)),
          listen_dev(
            div,
            "click_outside",
            /*onClickOutside*/
            ctx[8],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*onSelectItem, itemsFiltered*/
      68) {
        each_value = /*itemsFiltered*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(88:1) {#if itemsFiltered.length && showList}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let li;
  let t_value = (
    /*item*/
    ctx[14].title + ""
  );
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t = claim_text(li_nodes, t_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "svelte-1m9l8b1");
      add_location(li, file9, 91, 5, 2523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t);
      if (!mounted) {
        dispose = listen_dev(
          li,
          "click",
          function() {
            if (is_function(
              /*onSelectItem*/
              ctx[6](
                /*item*/
                ctx[14]
              )
            ))
              ctx[6](
                /*item*/
                ctx[14]
              ).apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*itemsFiltered*/
      4 && t_value !== (t_value = /*item*/
      ctx[14].title + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(91:4) {#each itemsFiltered as item}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let t0;
  let input;
  let input_id_value;
  let input_class_value;
  let input_autocorrect_value;
  let input_autocomplete_value;
  let input_placeholder_value;
  let t1;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*selectedItems*/
    ctx[3]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  let if_block = (
    /*itemsFiltered*/
    ctx[2].length && /*showList*/
    ctx[4] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      input = element("input");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", {
        type: true,
        id: true,
        class: true,
        autocorrect: true,
        autocomplete: true,
        placeholder: true
      });
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(div0, "class", "selected-items svelte-1m9l8b1");
      add_location(div0, file9, 67, 1, 1876);
      attr_dev(input, "type", "text");
      attr_dev(input, "id", input_id_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*field*/
        (_a = ctx[0].attributes.classes) == null ? void 0 : _a.join(" ")
      ) + " svelte-1m9l8b1");
      attr_dev(input, "autocorrect", input_autocorrect_value = /*field*/
      ctx[0].attributes.autocorrect);
      attr_dev(input, "autocomplete", input_autocomplete_value = /*field*/
      ctx[0].attributes.autocomplete);
      attr_dev(input, "placeholder", input_placeholder_value = /*field*/
      ctx[0].attributes.placeholder);
      add_location(input, file9, 76, 1, 2087);
      attr_dev(div1, "class", "autocomplete-wrapper svelte-1m9l8b1");
      add_location(div1, file9, 66, 0, 1840);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, input);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "keyup",
            /*onFilter*/
            ctx[5],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a;
      if (dirty & /*onDeselectItem, selectedItems*/
      136) {
        each_value_1 = /*selectedItems*/
        ctx2[3];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*field*/
      1 && input_id_value !== (input_id_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(input, "id", input_id_value);
      }
      if (dirty & /*field*/
      1 && input_class_value !== (input_class_value = null_to_empty(
        /*field*/
        (_a = ctx2[0].attributes.classes) == null ? void 0 : _a.join(" ")
      ) + " svelte-1m9l8b1")) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*field*/
      1 && input_autocorrect_value !== (input_autocorrect_value = /*field*/
      ctx2[0].attributes.autocorrect)) {
        attr_dev(input, "autocorrect", input_autocorrect_value);
      }
      if (dirty & /*field*/
      1 && input_autocomplete_value !== (input_autocomplete_value = /*field*/
      ctx2[0].attributes.autocomplete)) {
        attr_dev(input, "autocomplete", input_autocomplete_value);
      }
      if (dirty & /*field*/
      1 && input_placeholder_value !== (input_placeholder_value = /*field*/
      ctx2[0].attributes.placeholder)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
      if (
        /*itemsFiltered*/
        ctx2[2].length && /*showList*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AutoComplete", slots, []);
  let { field } = $$props;
  const dispatch = createEventDispatcher();
  let value = null;
  let items = [];
  let itemsFiltered = [];
  let selectedItems = [];
  let showList = false;
  let filter_length = 0;
  if (field.extra) {
    if (field.extra.loadItemes) {
      items = field.extra.loadItemes;
    }
    if (field.extra.filter_length) {
      filter_length = field.extra.filter_length;
    }
  }
  const onFilter = (event) => {
    const keyword = event.currentTarget.value;
    if (keyword.length > filter_length) {
      const filtered = items.filter((item) => {
        return item.title.toLowerCase().includes(keyword.toLowerCase());
      });
      if (filtered.length) {
        $$invalidate(2, itemsFiltered = filtered);
      } else {
        $$invalidate(2, itemsFiltered = []);
      }
      itemsFiltered.length ? $$invalidate(4, showList = true) : $$invalidate(4, showList = false);
    } else {
      $$invalidate(4, showList = false);
    }
  };
  const onSelectItem = (item) => (e) => {
    $$invalidate(1, value = null);
    items = items.filter((_item) => _item.value !== item.value);
    $$invalidate(2, itemsFiltered = itemsFiltered.filter((_item) => _item.value !== item.value));
    $$invalidate(3, selectedItems = [...selectedItems, item]);
    if (!items.length) {
      $$invalidate(4, showList = false);
    }
    dispatch("changeValue", { name: field.name, value: selectedItems });
  };
  const onDeselectItem = (item) => async (e) => {
    $$invalidate(3, selectedItems = await selectedItems.filter((_item) => _item.value !== item.value));
    items = [...items, item];
    $$invalidate(2, itemsFiltered = [...itemsFiltered, item]);
    dispatch("changeValue", { name: field.name, value: selectedItems });
  };
  const onClickOutside = (e) => {
    $$invalidate(4, showList = false);
  };
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<AutoComplete> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AutoComplete> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const click_handler = () => {
    $$invalidate(4, showList = false);
    $$invalidate(1, value = null);
  };
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    clickOutside,
    field,
    dispatch,
    value,
    items,
    itemsFiltered,
    selectedItems,
    showList,
    filter_length,
    onFilter,
    onSelectItem,
    onDeselectItem,
    onClickOutside
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("items" in $$props2)
      items = $$props2.items;
    if ("itemsFiltered" in $$props2)
      $$invalidate(2, itemsFiltered = $$props2.itemsFiltered);
    if ("selectedItems" in $$props2)
      $$invalidate(3, selectedItems = $$props2.selectedItems);
    if ("showList" in $$props2)
      $$invalidate(4, showList = $$props2.showList);
    if ("filter_length" in $$props2)
      filter_length = $$props2.filter_length;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    field,
    value,
    itemsFiltered,
    selectedItems,
    showList,
    onFilter,
    onSelectItem,
    onDeselectItem,
    onClickOutside,
    input_input_handler,
    click_handler
  ];
}
var AutoComplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { field: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AutoComplete",
      options,
      id: create_fragment11.name
    });
  }
  get field() {
    throw new Error("<AutoComplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<AutoComplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AutoComplete_default = AutoComplete;

// node_modules/svelte-formly/components/Label.svelte
var file10 = "node_modules\\svelte-formly\\components\\Label.svelte";
function create_if_block6(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[0].attributes.label && create_if_block_13(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*field*/
        ctx2[0].attributes.label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(4:0) {#if field.attributes}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let label;
  let t_value = (
    /*field*/
    ctx[0].attributes.label + ""
  );
  let t;
  let label_for_value;
  const block = {
    c: function create() {
      label = element("label");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t = claim_text(label_nodes, t_value);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label, "for", label_for_value = /*field*/
      ctx[0].attributes.id);
      attr_dev(label, "class", "label");
      add_location(label, file10, 5, 2, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field*/
      1 && t_value !== (t_value = /*field*/
      ctx2[0].attributes.label + ""))
        set_data_dev(t, t_value);
      if (dirty & /*field*/
      1 && label_for_value !== (label_for_value = /*field*/
      ctx2[0].attributes.id)) {
        attr_dev(label, "for", label_for_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(5:1) {#if field.attributes.label}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[0].attributes && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*field*/
        ctx2[0].attributes
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, []);
  let { field } = $$props;
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<Label> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Label> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({ field });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment12.name
    });
  }
  get field() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/svelte-formly/components/Formly.svelte
var { Error: Error_1, Object: Object_12 } = globals;
var file11 = "node_modules\\svelte-formly\\components\\Formly.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*is_duplicated*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(133:0) {#if current_form}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let form;
  let t0;
  let button0;
  let t1_value = (
    /*btnSubmit*/
    ctx[0].text + ""
  );
  let t1;
  let button0_class_value;
  let t2;
  let button1;
  let t3_value = (
    /*btnReset*/
    ctx[1].text + ""
  );
  let t3;
  let button1_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*current_form*/
    ctx[3].fields
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      form = element("form");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      button0 = element("button");
      t1 = text(t1_value);
      t2 = space();
      button1 = element("button");
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", {});
      var form_nodes = children(form);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(form_nodes);
      }
      t0 = claim_space(form_nodes);
      button0 = claim_element(form_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(button0_nodes, t1_value);
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(form_nodes);
      button1 = claim_element(form_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(button1_nodes, t3_value);
      button1_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c, _d;
      attr_dev(button0, "type", "submit");
      attr_dev(button0, "class", button0_class_value = /*btnSubmit*/
      ctx[0].classes && /*btnSubmit*/
      ((_a = ctx[0].classes) == null ? void 0 : _a.length) ? (
        /*btnSubmit*/
        (_b = ctx[0].classes) == null ? void 0 : _b.join(" ")
      ) : null);
      add_location(button0, file11, 159, 3, 4570);
      attr_dev(button1, "type", "reset");
      attr_dev(button1, "class", button1_class_value = /*btnReset*/
      ctx[1].classes && /*btnReset*/
      ((_c = ctx[1].classes) == null ? void 0 : _c.length) ? (
        /*btnReset*/
        (_d = ctx[1].classes) == null ? void 0 : _d.join(" ")
      ) : null);
      add_location(button1, file11, 165, 3, 4735);
      add_location(form, file11, 145, 2, 4041);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(form, null);
      }
      append_hydration_dev(form, t0);
      append_hydration_dev(form, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(form, t2);
      append_hydration_dev(form, button1);
      append_hydration_dev(button1, t3);
      ctx[12](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(form, "submit", prevent_default(
            /*onSubmit*/
            ctx[7]
          ), false, true, false),
          listen_dev(form, "reset", prevent_default(
            /*onReset*/
            ctx[8]
          ), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a, _b, _c, _d;
      if (dirty & /*current_form, getFieldByType, onChangeValue*/
      88) {
        each_value = /*current_form*/
        ctx2[3].fields;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(form, t0);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if ((!current || dirty & /*btnSubmit*/
      1) && t1_value !== (t1_value = /*btnSubmit*/
      ctx2[0].text + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & /*btnSubmit*/
      1 && button0_class_value !== (button0_class_value = /*btnSubmit*/
      ctx2[0].classes && /*btnSubmit*/
      ((_a = ctx2[0].classes) == null ? void 0 : _a.length) ? (
        /*btnSubmit*/
        (_b = ctx2[0].classes) == null ? void 0 : _b.join(" ")
      ) : null)) {
        attr_dev(button0, "class", button0_class_value);
      }
      if ((!current || dirty & /*btnReset*/
      2) && t3_value !== (t3_value = /*btnReset*/
      ctx2[1].text + ""))
        set_data_dev(t3, t3_value);
      if (!current || dirty & /*btnReset*/
      2 && button1_class_value !== (button1_class_value = /*btnReset*/
      ctx2[1].classes && /*btnReset*/
      ((_c = ctx2[1].classes) == null ? void 0 : _c.length) ? (
        /*btnReset*/
        (_d = ctx2[1].classes) == null ? void 0 : _d.join(" ")
      ) : null)) {
        attr_dev(button1, "class", button1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      destroy_each(each_blocks, detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(145:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let error;
  let current;
  error = new Error_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const error_changes = {};
      if (dirty & /*$$scope*/
      524288) {
        error_changes.$$scope = { dirty, ctx: ctx2 };
      }
      error.$set(error_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(error, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(134:1) {#if is_duplicated}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let label;
  let t0;
  let switch_instance;
  let t1;
  let dirty;
  let current;
  label = new Label_default({
    props: { field: (
      /*field*/
      ctx[16]
    ) },
    $$inline: true
  });
  var switch_value = (
    /*getFieldByType*/
    ctx[4](
      /*field*/
      ctx[16]
    )
  );
  function switch_props(ctx2) {
    return {
      props: { field: (
        /*field*/
        ctx2[16]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "changeValue",
      /*onChangeValue*/
      ctx[6]
    );
  }
  dirty = new Dirty_default({
    props: { field: (
      /*field*/
      ctx[16]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(label.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(dirty.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(label.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(dirty.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(label, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(dirty, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty$1) {
      const label_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        label_changes.field = /*field*/
        ctx2[16];
      label.$set(label_changes);
      const switch_instance_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        switch_instance_changes.field = /*field*/
        ctx2[16];
      if (switch_value !== (switch_value = /*getFieldByType*/
      ctx2[4](
        /*field*/
        ctx2[16]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "changeValue",
            /*onChangeValue*/
            ctx2[6]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t1.parentNode, t1);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      const dirty_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        dirty_changes.field = /*field*/
        ctx2[16];
      dirty.$set(dirty_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(dirty.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(dirty.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(label, detaching);
      if (detaching)
        detach_dev(t0);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(dirty, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(154:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      prefix: (
        /*field*/
        ctx[16].prefix
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tag.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tag.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & /*current_form*/
      8)
        tag_changes.prefix = /*field*/
        ctx2[16].prefix;
      if (dirty & /*$$scope, current_form*/
      524296) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tag, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(148:4) {#if field.prefix?.tag}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let label;
  let t0;
  let switch_instance;
  let t1;
  let dirty;
  let current;
  label = new Label_default({
    props: { field: (
      /*field*/
      ctx[16]
    ) },
    $$inline: true
  });
  var switch_value = (
    /*getFieldByType*/
    ctx[4](
      /*field*/
      ctx[16]
    )
  );
  function switch_props(ctx2) {
    return {
      props: { field: (
        /*field*/
        ctx2[16]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "changeValue",
      /*onChangeValue*/
      ctx[6]
    );
  }
  dirty = new Dirty_default({
    props: { field: (
      /*field*/
      ctx[16]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(label.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(dirty.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(label.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(dirty.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(label, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(dirty, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty$1) {
      const label_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        label_changes.field = /*field*/
        ctx2[16];
      label.$set(label_changes);
      const switch_instance_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        switch_instance_changes.field = /*field*/
        ctx2[16];
      if (switch_value !== (switch_value = /*getFieldByType*/
      ctx2[4](
        /*field*/
        ctx2[16]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "changeValue",
            /*onChangeValue*/
            ctx2[6]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t1.parentNode, t1);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      const dirty_changes = {};
      if (dirty$1 & /*current_form*/
      8)
        dirty_changes.field = /*field*/
        ctx2[16];
      dirty.$set(dirty_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(dirty.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(dirty.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(label, detaching);
      if (detaching)
        detach_dev(t0);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(dirty, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(149:5) <Tag prefix={field.prefix}>",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if (
      /*field*/
      (_a = ctx2[16].prefix) == null ? void 0 : _a.tag
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(147:3) {#each current_form.fields as field}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let p;
  let code;
  let b;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      code = element("code");
      b = element("b");
      t = text("Error! Detect duplicate fields(name or id attributes), make sure you put unique name\n						and id for each field.");
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      code = claim_element(p_nodes, "CODE", {});
      var code_nodes = children(code);
      b = claim_element(code_nodes, "B", {});
      var b_nodes = children(b);
      t = claim_text(b_nodes, "Error! Detect duplicate fields(name or id attributes), make sure you put unique name\n						and id for each field.");
      b_nodes.forEach(detach_dev);
      code_nodes.forEach(detach_dev);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file11, 137, 6, 3865);
      add_location(code, file11, 136, 4, 3853);
      add_location(p, file11, 135, 3, 3845);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, code);
      append_hydration_dev(code, b);
      append_hydration_dev(b, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(135:2) <Error>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*current_form*/
    ctx[3] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*current_form*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*current_form*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Formly", slots, []);
  const ListFieldType = [
    { type: "input", component: Input_default },
    { type: "select", component: Select_default },
    { type: "file", component: File_default },
    { type: "textarea", component: Textarea_default },
    { type: "checkbox", component: Checkbox_default },
    { type: "radio", component: Radio_default },
    {
      type: "autocomplete",
      component: AutoComplete_default
    }
  ];
  const getFieldByType = ({ type }) => {
    var _a;
    return (_a = ListFieldType.find((field) => field.type === type)) == null ? void 0 : _a.component;
  };
  let { fields = [] } = $$props;
  let { btnSubmit = { text: "Submit" } } = $$props;
  let { btnReset = { text: "Reset" } } = $$props;
  let { form_name = "" } = $$props;
  let { realtime = false } = $$props;
  let _formEl;
  const dispatch = createEventDispatcher();
  let values = {};
  let current_form = { form_name, fields, values, valid: true };
  const is_duplicated = isFieldDuplicated(fields);
  onMount(async () => {
    await Promise.all(fields.map(async (field) => {
      values[`${field.name}`] = field.value ?? null;
      field = await preprocess_and_validate_field(current_form, field, values);
      return field;
    }));
    const dirty = fields.find((field) => {
      if (field.validation) {
        return field.validation.dirty === true;
      }
    });
    $$invalidate(3, current_form = {
      ...current_form,
      fields,
      values,
      valid: dirty ? false : true
    });
  });
  storeForms.save(current_form);
  const onChangeValue = async (event) => {
    const values2 = current_form.values;
    const _fields = await Promise.all(current_form.fields.map(async (field) => {
      if (field.name === event.detail.name) {
        values2["touched"] = field.name;
        field.value = event.detail.value;
        values2[`${field.name}`] = event.detail.value;
      }
      field = await preprocess_and_validate_field(current_form, field, values2);
      return field;
    }));
    const dirty = _fields.find((field) => {
      if (field.validation) {
        return field.validation.dirty === true;
      }
    });
    $$invalidate(3, current_form = {
      ...current_form,
      fields: _fields,
      values: values2,
      valid: dirty ? false : true
    });
    storeForms.save(current_form);
    if (realtime) {
      dispatch("update", {
        ...current_form.values,
        valid: current_form.valid
      });
    }
  };
  const onSubmit = async () => {
    const values2 = await getValues(form_name);
    dispatch("submit", { ...values2, valid: current_form.valid });
  };
  const onReset = async () => {
    Object.keys(values).forEach((key) => {
      values[key] = null;
    });
    await storeForms.resetValues(form_name);
    $$invalidate(3, current_form.values = values, current_form);
  };
  const writable_props = ["fields", "btnSubmit", "btnReset", "form_name", "realtime"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Formly> was created with unknown prop '${key}'`);
  });
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _formEl = $$value;
      $$invalidate(2, _formEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(9, fields = $$props2.fields);
    if ("btnSubmit" in $$props2)
      $$invalidate(0, btnSubmit = $$props2.btnSubmit);
    if ("btnReset" in $$props2)
      $$invalidate(1, btnReset = $$props2.btnReset);
    if ("form_name" in $$props2)
      $$invalidate(10, form_name = $$props2.form_name);
    if ("realtime" in $$props2)
      $$invalidate(11, realtime = $$props2.realtime);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    isFieldDuplicated,
    storeForms,
    getValues,
    preprocess_and_validate_field,
    Tag: Tag_default,
    Error: Error_default,
    Dirty: Dirty_default,
    Input: Input_default,
    Select: Select_default,
    File: File_default,
    Textarea: Textarea_default,
    Checkbox: Checkbox_default,
    Radio: Radio_default,
    AutoComplete: AutoComplete_default,
    Label: Label_default,
    ListFieldType,
    getFieldByType,
    fields,
    btnSubmit,
    btnReset,
    form_name,
    realtime,
    _formEl,
    dispatch,
    values,
    current_form,
    is_duplicated,
    onChangeValue,
    onSubmit,
    onReset
  });
  $$self.$inject_state = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(9, fields = $$props2.fields);
    if ("btnSubmit" in $$props2)
      $$invalidate(0, btnSubmit = $$props2.btnSubmit);
    if ("btnReset" in $$props2)
      $$invalidate(1, btnReset = $$props2.btnReset);
    if ("form_name" in $$props2)
      $$invalidate(10, form_name = $$props2.form_name);
    if ("realtime" in $$props2)
      $$invalidate(11, realtime = $$props2.realtime);
    if ("_formEl" in $$props2)
      $$invalidate(2, _formEl = $$props2._formEl);
    if ("values" in $$props2)
      values = $$props2.values;
    if ("current_form" in $$props2)
      $$invalidate(3, current_form = $$props2.current_form);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    btnSubmit,
    btnReset,
    _formEl,
    current_form,
    getFieldByType,
    is_duplicated,
    onChangeValue,
    onSubmit,
    onReset,
    fields,
    form_name,
    realtime,
    form_binding
  ];
}
var Formly = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      fields: 9,
      btnSubmit: 0,
      btnReset: 1,
      form_name: 10,
      realtime: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Formly",
      options,
      id: create_fragment13.name
    });
  }
  get fields() {
    throw new Error_1("<Formly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fields(value) {
    throw new Error_1("<Formly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnSubmit() {
    throw new Error_1("<Formly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnSubmit(value) {
    throw new Error_1("<Formly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnReset() {
    throw new Error_1("<Formly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnReset(value) {
    throw new Error_1("<Formly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form_name() {
    throw new Error_1("<Formly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form_name(value) {
    throw new Error_1("<Formly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get realtime() {
    throw new Error_1("<Formly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set realtime(value) {
    throw new Error_1("<Formly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Formly_default = Formly;
export {
  Error_default as Error,
  File_default as File,
  Formly_default as Formly,
  Input_default as Input,
  Message_default as Message,
  Select_default as Select,
  Tag_default as Tag,
  clickOutside,
  formsStore,
  getFormByName,
  getValues,
  inArray,
  isFieldDuplicated,
  isRequired,
  preprocessField,
  preprocess_and_validate_field,
  storeForms,
  validate
};
//# sourceMappingURL=svelte-formly.js.map
