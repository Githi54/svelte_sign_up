<script>import { createEventDispatcher, onMount } from 'svelte';
import { isFieldDuplicated, storeForms, validate, getValues, preprocessField } from '../utils';
// Import others components.
import Tag from './Tag.svelte';
import Message from './Message.svelte';
import Error from './Error.svelte';
// Import field components.
import Input from './fields/Input.svelte';
import Select from './fields/Select.svelte';
import File from './fields/File.svelte';
const ListFieldType = [
    {
        type: 'input',
        component: Input
    },
    {
        type: 'select',
        component: Select
    },
    {
        type: 'file',
        component: File
    }
];
// Get field by type.
const getFieldByType = ({ type }) => {
    return ListFieldType.find((field) => field.type === type)?.component;
};
// Props.
export let fields = [];
export let form_name = '';
export let realtime = false;
let _formEl;
// Dispatch values.
const dispatch = createEventDispatcher();
// Init values.
let values = {};
let current_form = {
    form_name,
    fields,
    values,
    valid: true
};
// Init form.
onMount(async () => {
    await Promise.all(fields.map(async (field) => {
        values[`${field.name}`] = field.value ?? null;
        // 1.preprocess
        if (field.preprocess) {
            field = await preprocessField(field, current_form.fields, values);
            values[`${field.name}`] = field.value ?? null;
        }
        // 2.validation
        if (field.rules) {
            field = await validate(field);
        }
        return field;
    }));
    // Find dirty in the current form.
    const dirty = fields.find((field) => {
        if (field.validation) {
            return field.validation.dirty === true;
        }
    });
    current_form = { ...current_form, fields: fields, values, valid: dirty ? false : true };
});
// Check if name/id fields are duplicated.
const is_duplicated = isFieldDuplicated(fields);
// Init forms.
storeForms.save(current_form);
// On change value field.
const onChangeValue = async (event) => {
    const values = current_form.values;
    const _fields = await Promise.all(current_form.fields.map(async (field) => {
        if (field.name === event.detail.name) {
            values['touched'] = field.name;
            field.value = event.detail.value;
            values[`${field.name}`] = event.detail.value;
        }
        // 1.preprocess
        if (field.preprocess) {
            field = await preprocessField(field, current_form.fields, values);
            values[`${field.name}`] = field.value ?? null;
        }
        // 2.validation
        if (field.rules) {
            field = await validate(field);
        }
        return field;
    }));
    // Find dirty in the current form.
    const dirty = _fields.find((field) => {
        if (field.validation) {
            return field.validation.dirty === true;
        }
    });
    current_form = { ...current_form, fields: _fields, values, valid: dirty ? false : true };
    // Update form.
    storeForms.save(current_form);
    if (realtime) {
        dispatch('update', { ...current_form.values, valid: current_form.valid });
    }
};
// Submit form.
const onSubmit = async () => {
    const values = await getValues(form_name);
    dispatch('submit', { ...values, valid: current_form.valid });
};
// Reset form.
const onReset = async () => {
    _formEl.reset();
    Object.keys(values).forEach((key) => {
        values[key] = null;
    });
    await storeForms.resetValues(form_name);
};
</script>

{#if current_form}
	{#if is_duplicated}
		<Error>
			<p>
				Error! Detect duplicate fields(name or id attributes), make sure you put unique name and id
				for each field.
			</p>
		</Error>
	{:else}
		<form bind:this={_formEl} on:submit|preventDefault={onSubmit} on:reset|preventDefault={onReset}>
			{#each current_form.fields as field}
				{#if field.prefix?.tag}
					<Tag tag={field.prefix ? field.prefix.tag : ''}>
						<svelte:component this={getFieldByType(field)} {field} on:changeValue={onChangeValue} />
					</Tag>
				{:else}
					<svelte:component this={getFieldByType(field)} {field} on:changeValue={onChangeValue} />
				{/if}
				{#if field.validation && field.validation.errors.length}
					{#each field.validation.errors as error}
						<Message {error} messages={field.messages ? field.messages : []} />
					{/each}
				{/if}
			{/each}
			<button type="submit">submit</button>
			<button type="reset">reset</button>
		</form>
	{/if}
{/if}
